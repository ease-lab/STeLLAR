package main

import (
	"flag"
	"fmt"
	"lambda-benchmarking/client/benchmarking"
	"lambda-benchmarking/client/visualization"
	"log"
	"os"
	"path/filepath"
	"time"
)

//Note: those variables are pointers
var requestsFlag = flag.Int("requests", 1, "Number of outstanding requests for this run.")
var payloadLengthFlag = flag.Int("payloadLengthBytes", 8, "Length of the payload generated by the lambda function.")
var outputPathFlag = flag.String("outputPath", "latency-samples", "The path where latency samples should be written.")
var frequencySecondsFlag = flag.Int("frequencySeconds", -1, "Frequency at which the latency profiler operates.")
var burstsNumberFlag = flag.Int("bursts", 5, "Number of bursts which the latency profiler will trigger.")

// TODO: replace those 2 flags
var execMsFlag = flag.Int("execMs", 80, "Time duration for the lambda function to busy spin.")

//var lambdaIncrementLimitFlag = flag.Int("lambdaIncrementLimit", 2e8, "Increment limit for the lambda function to busy spin on.")

func init() {
	log.Printf("Started benchmarking HTTP client on %v.", time.Now().Format(time.RFC850))

	flag.Parse()
	log.Printf("Parameters entered: %d requests in a burst, %dbytes payload length, %dms busy spin, %d profiler run frequency, output path was set to `%s`.",
		*requestsFlag, *payloadLengthFlag, *execMsFlag, *frequencySecondsFlag, *outputPathFlag)
}

func main() {
	outputDirectoryPath := filepath.Join(*outputPathFlag, time.Now().Format(time.RFC850))
	log.Printf("Creating working directory at %s", outputDirectoryPath)
	if err := os.Mkdir(outputDirectoryPath, os.ModePerm); err != nil {
		log.Fatal(err)
	}

	csvFile, err := os.Create(filepath.Join(outputDirectoryPath, fmt.Sprintf(
		"%dbursts_%dreqs_freq%ds_payload%db_exec%dms.csv",
		*burstsNumberFlag,
		*requestsFlag,
		*frequencySecondsFlag,
		*payloadLengthFlag,
		*execMsFlag)))
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := csvFile.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	burstDeltas := createBurstDeltas()

	log.Println("Running profiler...")
	benchmarking.SafeWriterInstance.Initialize(csvFile)
	benchmarking.RunProfiler(burstDeltas, *requestsFlag, *execMsFlag, *payloadLengthFlag)

	log.Println("Flushing results to CSV file...")
	benchmarking.SafeWriterInstance.Writer.Flush()

	log.Println("Plotting bursts from CSV file...")
	visualization.ExtractBurstsAndGeneratePlots(*burstsNumberFlag, burstDeltas, csvFile, outputDirectoryPath)

	log.Println("Exiting...")
}

func createBurstDeltas() []time.Duration {
	var burstDeltas []time.Duration
	if *frequencySecondsFlag != -1 {
		// latency profiler run, delta is constant
		burstDeltas = make([]time.Duration, *burstsNumberFlag)
		for i := range burstDeltas {
			burstDeltas[i] = time.Duration(*frequencySecondsFlag) * time.Second
		}
	} else {
		// cold start delta identifier run, delta varies so that the exact timeout can be identified
		burstDeltas = []time.Duration{
			time.Duration(0),
			500 * time.Millisecond,
			time.Second,
			5 * time.Second,
			15 * time.Second,
			30 * time.Second,
			45 * time.Second,
			time.Minute,
			5 * time.Minute,
			8 * time.Minute,
			10 * time.Minute,
			12 * time.Minute,
			20 * time.Minute,
			30 * time.Minute,
			time.Hour,
			2 * time.Hour,
		}
		burstDeltas = burstDeltas[:*burstsNumberFlag]
	}
	return burstDeltas
}
