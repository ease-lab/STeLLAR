package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"lambda-benchmarking/client/benchmarking"
	"log"
	"os"
	"sync"
	"time"
)

//Note: those variables are pointers
var requestsFlag = flag.Int("requests", 1, "Number of outstanding requests for this run.")
var execMillisecondsFlag = flag.Int("execMilliseconds", 80, "Time duration for the lambda function to busy spin.")
var payloadLengthFlag = flag.Int("payloadLengthBytes", 8, "Length of the payload generated by the lambda function.")
var outputPathFlag = flag.String("outputPath", "latency-samples", "The path where latency samples should be written.")

var burstRelativeDeltas []time.Duration

func init() {
	log.Printf("Started benchmarking HTTP client on %v.", time.Now().Format(time.RFC850))
	burstDeltas := []time.Duration{
		time.Duration(0),
		500 * time.Millisecond,
		time.Second,
		5 * time.Second,
		15 * time.Second,
		30 * time.Second,
		time.Minute,
		//10 * time.Minute,
		//15 * time.Minute,
		//30 * time.Minute,
		//45 * time.Minute,
		//time.Hour,
		//2 * time.Hour,
	}

	burstRelativeDeltas = []time.Duration{burstDeltas[0]}
	for _, burstDelta := range burstDeltas[1:] {
		burstRelativeDeltas = append(burstRelativeDeltas,
			burstRelativeDeltas[len(burstRelativeDeltas)-1]+burstDelta)
	}
}

func main() {
	flag.Parse()
	log.Printf("Parameters entered: %d requests in a burst, %dbytes payload length, %dms busy spin, output path was set to `%s`.",
		*requestsFlag, *payloadLengthFlag, *execMillisecondsFlag, *outputPathFlag)

	file, err := os.Create(fmt.Sprintf("%s/payload%dbytes_exec%dms_%s.csv",
		*outputPathFlag,
		*payloadLengthFlag,
		*execMillisecondsFlag,
		time.Now().Format(time.RFC850)))
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	safeWriter := benchmarking.SafeWriter{Writer: writer}
	safeWriter.WriteRowToFile(
		"AWS Request ID",
		"Sent At",
		"Received At",
		"Client Latency (ms)",
		"Burst ID")
	defer safeWriter.Writer.Flush()

	var burstsWaitGroup sync.WaitGroup
	for burstId, relativeDelta := range burstRelativeDeltas {
		log.Printf("Scheduling burst %d (%v) for %v.",
			burstId,
			burstRelativeDeltas[burstId],
			time.Now().Add(burstRelativeDeltas[burstId]).Format(time.StampNano))
		burstsWaitGroup.Add(1)
		go burst(&burstsWaitGroup, &safeWriter, burstId, relativeDelta)
	}

	burstsWaitGroup.Wait()
	log.Println("All bursts completed, now flushing to disk and exiting program.")
}

func burst(burstsWaitGroup *sync.WaitGroup, safeWriter *benchmarking.SafeWriter, burstId int, relativeDelta time.Duration) {
	defer burstsWaitGroup.Done()
	time.Sleep(relativeDelta)

	log.Printf("Starting burst %d (%v) on %v: making %d requests to API Gateway.",
		burstId,
		burstRelativeDeltas[burstId],
		time.Now().Format(time.StampNano),
		*requestsFlag)

	var requestsWaitGroup sync.WaitGroup
	for i := 0; i < *requestsFlag; i++ {
		requestsWaitGroup.Add(1)
		go safeWriter.GenerateLatencyRecord(&requestsWaitGroup, *execMillisecondsFlag, *payloadLengthFlag, burstId)
	}
	requestsWaitGroup.Wait()
	log.Printf("Received all responses for burst %d.", burstId)
}
